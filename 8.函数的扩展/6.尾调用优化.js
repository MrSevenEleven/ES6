// 什么是尾调用
    // 就是指某个函数的最后一步是调用另一个函数。
    //     function f(x){
    //         return g(x);
    //     }
    // 尾调用不一定出现在函数尾部，只要是最后一步操作即可。
    //     function f(x) {
    //         if (x > 0) {
    //             return m(x)
    //         }
    //         return n(x);
    //     }

// 尾调用优化
    // 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。
    // 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。
    // 如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。

    // 尾调用优化即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
    // 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

// 尾递归
    // 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
    // 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。
    // 但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
        function factorial(n, total) {
            if (n === 1) return total;
            return factorial(n - 1, n * total);
        }
        factorial(5, 1) // 120

// 递归函数的改写
    // 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。
    // 这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？
        // 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。
            // function tailFactorial(n, total) {
            //     if (n === 1) return total;
            //     return tailFactorial(n - 1, n * total);
            // }
            //
            // function factorial(n) {
            //     return tailFactorial(n, 1);
            // }
            //
            // factorial(5) // 120
    // 第二种方法就简单多了，就是采用 ES6 的函数默认值。
        // function factorial(n, total = 1) {
        //     if (n === 1) return total;
        //     return factorial(n - 1, n * total);
        // }
        //
        // factorial(5) // 120

// 严格模式
    // ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。
    //     这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
    //
    //     func.arguments：返回调用时函数的参数。
    //     func.caller：返回调用当前函数的那个函数。

        // function restricted() {
        //     'use strict';
        //     console.log(restricted.caller);    // 报错
        //     console.log(restricted.arguments); // 报错
        // }
        // restricted();

// 尾递归优化的实现
    // 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。
    // 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。